/*
 * pocc-driver-past.c: this file is part of the PoCC project.
 *
 * PoCC, the Polyhedral Compiler Collection package
 *
 * Copyright (C) 2009-2014 Louis-Noel Pouchet
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1
 * of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * The complete GNU General Public Licence Notice can be found as the
 * `COPYING.LESSER' file in the root directory.
 *
 * Author:
 * Louis-Noel Pouchet <Louis-Noel.Pouchet@inria.fr>
 *
 */
#if HAVE_CONFIG_H
# include <pocc-utils/config.h>
#endif
#if HAVE_CONFIG_H
# include <pocc-utils/config.h>
#endif
#include <pocc/common.h>

#include <stdio.h>
#include <pocc/pocc-driver-past.h>
#include <pocc/driver-pastops.h>
#include <pocc/driver-clan.h>
#include <pocc/driver-candl.h>
#include <pocc/driver-letsee.h>
#include <pocc/driver-pluto.h>
#include <pocc/driver-codegen.h>
#include <pocc/driver-cloog.h>
#include <pocc/driver-clastops.h>
#include <pocc/driver-ponos.h>
#include <pocc/driver-psimdkzer.h>
#include <pocc/exec.h>
#include <pocc/error.h>
#ifdef POCC_DEVEL_MODE
# include <pocc/driver-cdscgr.h>
#endif

#include <past/past.h>
#include <past/past_api.h>
#include <past/pprint.h>
#include <irconverter/pastScopRecognizer.h>
#include <irconverter/pastScopConverter.h>

#ifdef POCC_HOST_MODE
#include <pocc/driver-histencil.h>
#endif


s_past_node_t*
pocc_past2past (s_past_node_t* input_tree,
		s_pocc_options_t* poptions)
{
  int i, i_trees;
  // Do not pprint the output tree, instead return it.
  poptions->past_pretty_print = 0;
  s_pocc_utils_options_t* puoptions = pocc_utils_options_malloc ();
  s_past_node_t* output_tree = past_clone (input_tree);
  pip_init ();
  if (poptions->verbose)
    {
      printf ("[PoCC] Compiling tree:\n");
      past_pprint (stdout, output_tree);
      printf ("\n");
    }
  if (poptions->trash)
    {
      if (! poptions->quiet)
	printf ("[PoCC] Deleting files previously generated by PoCC for %s\n",
		poptions->input_file_name);
      char* args[3];
      args[0] = STR_POCC_ROOT_DIR "/generators/scripts/trash";
      args[1] = strdup (poptions->input_file_name);
      args[1][strlen (args[1]) - 2] = '\0';
      args[2] = NULL;
      pocc_exec (args, POCC_EXECV_HIDE_OUTPUT);
      XFREE(args[1]);
    }
  if (poptions->letsee == 0 && poptions->pluto == 0 && poptions->ponos == 0 && poptions->psimdkzer == 0)
    if (! poptions->quiet)
      printf ("[PoCC] INFO: pass-thru compilation, no optimization enabled\n");

#ifdef POCC_DEVEL_MODE
  if (poptions->cdscgr)
    {
      pocc_driver_cdscgr (poptions->input_file, poptions, puoptions);
    }
  else
    {
#endif
      // (1) Convert to scop.
      scoplib_scop_p scop = NULL;
      // Produce an array of basic blocks, each one is a distinct scop.
      s_past_node_t** nodes =
	pastScopRecognizer (output_tree, poptions->verbose);
      if (!nodes)
	{
	  pocc_error ("[PoCC] Cannot detect a SCoP in input tree");
	  return output_tree;
	}
      for (i_trees = 0; nodes && nodes[i_trees]; ++i_trees)
	{
	  printf ("[PoCC] INFO: Processing SCoP #%d\n", i_trees + 1);
	  s_past_node_t* tail = nodes[i_trees]->next;
	  nodes[i_trees]->next = NULL;
	  s_past_node_t* output_subtree = NULL;
	  scop = pastScopConverter (nodes[i_trees]);
	  if (! scop || scop->statement == NULL)
	    {
	      pocc_error ("[PoCC] No scop / no statement in SCoP");
	      output_subtree = past_clone (nodes[i_trees]);
	    }
	  else
	    {
	      if (poptions->histencil)
		{
#ifdef POCC_HOST_MODE
		  /* printf ("[pocc] recognized past tree:\n"); */
		  /* past_pprint (stdout, nodes[i_trees]); */
		  /* printf ("[pocc] recognized scop:\n"); */
		  /* scoplib_scop_print (stdout, scop); */
		  /* output_subtree = past_clone (nodes[i_trees]); */
		  pocc_driver_histencil (scop, nodes[i_trees],
		  			 poptions, puoptions);
		  output_subtree = poptions->output_past_tree;
#endif
		}
	      else
		{
		  if (poptions->verbose)
		    {
		      printf ("[PoCC] Dealing with:\n");
		      past_pprint (stdout, nodes[i_trees]);
		      scoplib_scop_print (stdout, scop);
		    }

		  // (2) If pass-thru, run candl.
		  if (! poptions->letsee || ! poptions->pluto)
		    pocc_driver_candl (scop, poptions, puoptions);

		  // (3) Perform LetSee.
		  if (poptions->letsee)
		    pocc_driver_letsee (scop, poptions, puoptions);

		  // (4) Perform PLuTo.
		  // Don't do it if already performed through LetSee.
		  if (poptions->pluto && ! poptions->letsee)
		    if (pocc_driver_pluto (scop, poptions, puoptions) ==
			EXIT_FAILURE)
		      exit (EXIT_FAILURE);

		  // (5) Perform Ponos.
		  if (poptions->ponos)
		    if (pocc_driver_ponos (scop, poptions, puoptions) ==
			EXIT_FAILURE)
		      exit (EXIT_FAILURE);

		  if (poptions->output_scoplib_file_name)
		    {
		      scoplib_scop_p tempscop = scoplib_scop_dup (scop);
		      if (poptions->cloogify_schedules)
			pocc_cloogify_scop (tempscop);
		      FILE* scopf =
			fopen (poptions->output_scoplib_file_name, "w");
		      if (scopf)
			{
			  scoplib_scop_print_dot_scop (scopf, tempscop);
			  fclose (scopf);
			}
		      scoplib_scop_free (tempscop);
		    }

		  // (6) Perform codgen.
		  // Don't do it if already performed through LetSee.
		  if (poptions->codegen && ! poptions->letsee)
		    pocc_driver_codegen (scop, poptions, puoptions);

		  // (7) Replace cloogstmt by actual PAST sub-trees for
		  // the statements.
		  s_past_node_t* ret =
		    pocc_driver_pastops_rebuild_statement_bodies
		    (scop, poptions->output_past_tree);

		  // Be clean.
		  scoplib_scop_free (scop);
		  output_subtree = ret;

		}

	      // Plug in new subtree.
	      // Extract the subtree and make it a BB.
	      past_set_parent (output_subtree);
	      if (past_node_is_a (output_subtree, past_root))
		{
		  PAST_DECLARE_TYPED(root, pr_out, output_subtree);
		  output_subtree = past_node_block_create (pr_out->body);
		  PAST_DECLARE_TYPED(block, pb_out, output_subtree);
		  pb_out->symboltable = pr_out->symboltable;
		  pb_out->artificial_bb = 1;
		}
	      nodes[i_trees]->next = tail;
	      s_past_node_t** dst = NULL;
	      if (past_node_is_a (nodes[i_trees], past_root))
		{
		  PAST_DECLARE_TYPED(root, pr, nodes[i_trees]);
		  dst = &(pr->body);
		}
	      else
		{
		  // Sub-tree encapsulated in a BB, by contract.
		  assert(past_node_is_a (nodes[i_trees], past_block));
		  PAST_DECLARE_TYPED(block, pb, nodes[i_trees]);
		  dst = &(pb->body);
		}
	      past_deep_free (*dst);
	      *dst = output_subtree;
	      output_subtree->parent = nodes[i_trees];
	    }
#ifdef POCC_DEVEL_MODE
	}
#endif
    }
  pip_close ();
  if (! poptions->quiet)
    printf ("[PoCC] All done.\n");

  return output_tree;
}
